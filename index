<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat with DeepsSeek</title>
    <style>
      [v-cloak]{display:none}
      @keyframes bgShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      .animated-gradient {
        background: linear-gradient(120deg, #0f172a, #1e1b4b, #111827, #0f172a);
        background-size: 300% 300%;
        animation: bgShift 18s ease infinite;
      }
      .neon-glow {
        box-shadow: 0 0 10px rgba(99,102,241,0.6), 0 0 30px rgba(99,102,241,0.35);
      }
      .neon-glow-soft {
        box-shadow: 0 0 8px rgba(99,102,241,0.35);
      }
    </style>
    <!-- TailwindCSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <!-- Markdown renderer + sanitizer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  </head>
  <body class="min-h-screen font-sans">
    <div id="app" class="flex min-h-screen" :class="theme==='dark' ? 'text-gray-100' : 'text-gray-800'">
      <!-- Background layers (toggle by theme) -->
      <div v-if="theme==='dark'" class="fixed inset-0 animated-gradient -z-10"></div>
      <div v-if="theme==='dark'" class="fixed inset-0 -z-10" style="background: radial-gradient(1200px 600px at 80% -10%, rgba(99,102,241,0.25), transparent 60%), radial-gradient(900px 500px at -10% 110%, rgba(16,185,129,0.18), transparent 60%);"></div>
      <div v-if="theme!=='dark'" class="fixed inset-0 -z-10 animated-gradient" style="filter: brightness(1.35);"></div>
      <div v-if="theme!=='dark'" class="fixed inset-0 -z-10" style="background: radial-gradient(1200px 600px at 80% -10%, rgba(99,102,241,0.12), transparent 60%), radial-gradient(900px 500px at -10% 110%, rgba(16,185,129,0.10), transparent 60%);"></div>
      
      <!-- History Sidebar -->
      <div :class="showHistory ? 'w-72' : 'w-0'" class="fixed left-0 top-0 h-screen overflow-hidden transition-all duration-300 z-30" style="transition: width 0.3s;">
        <div :class="theme==='dark' ? 'bg-slate-900/95 border-white/10' : 'bg-white/90 border-gray-200'" class="h-full border-r backdrop-blur-xl overflow-y-auto">
          <div class="p-4 border-b" :class="theme==='dark' ? 'border-white/10' : 'border-gray-200'">
            <div class="flex items-center justify-between mb-3">
              <h2 class="font-bold text-lg">History</h2>
              <button @click="showHistory = false" :class="theme==='dark' ? 'text-gray-400 hover:text-gray-200' : 'text-gray-500 hover:text-gray-700'" class="text-xl">&times;</button>
            </div>
            <!-- Search Bar -->
            <input
              v-model="historySearchQuery"
              type="text"
              placeholder="Search history..."
              :class="theme==='dark' ? 'bg-white/10 border-white/10 text-gray-100 placeholder-gray-400' : 'bg-white border-gray-300 text-gray-800 placeholder-gray-500'"
              class="w-full px-3 py-2 rounded-lg border text-sm mb-3 focus:outline-none focus:ring-2 focus:ring-indigo-400/60"
            />
            <button @click="clearHistory" :class="theme==='dark' ? 'bg-red-600/20 text-red-400 hover:bg-red-600/30 border-red-500/30' : 'bg-red-50 text-red-600 hover:bg-red-100 border-red-300'" class="w-full px-3 py-1.5 text-sm rounded-lg border">
              Clear All
            </button>
          </div>
          <div class="space-y-1 p-2">
            <div v-if="filteredHistory.length === 0" :class="theme==='dark' ? 'text-gray-400' : 'text-gray-500'" class="text-sm text-center py-4">
              No history found
            </div>
            <div v-for="(item, idx) in filteredHistory" :key="idx" @click="loadHistoryItem(item, idx)" :class="theme==='dark' ? 'bg-white/5 hover:bg-white/10 border-white/5' : 'bg-gray-50 hover:bg-gray-100 border-gray-200'" class="p-3 rounded-lg border cursor-pointer mb-1">
              <p class="text-sm font-medium truncate mb-1">{{ item.title || 'New Chat' }}</p>
              <p class="text-xs opacity-60">{{ formatTime(item.timestamp) }}</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Content -->
      <div class="flex-1 flex flex-col items-center w-full" :class="showHistory ? 'ml-0' : 'ml-0'" style="transition: margin-left 0.3s;">
        <header class="w-full py-5 mb-3">
          <div class="max-w-2xl mx-auto px-4 flex items-center justify-between">
            <div class="flex items-center gap-3">
              <button @click="showHistory = !showHistory" :class="theme==='dark' ? 'bg-white/10 text-gray-100 border-white/20 hover:bg-white/15' : 'bg-white text-gray-800 border-gray-200 hover:bg-gray-50'" class="px-3 py-1.5 rounded-lg border text-sm">☰ History</button>
              <h1 class="text-3xl font-extrabold tracking-wide"><span :class="theme==='dark' ? 'from-indigo-400 via-cyan-300 to-emerald-300' : 'from-indigo-700 via-cyan-600 to-emerald-600'" class="bg-gradient-to-r bg-clip-text text-transparent">Chat with AI</span></h1>
              <button @click="startNewChat" :class="theme==='dark' ? 'bg-white/10 text-gray-100 border-white/20 hover:bg-white/15' : 'bg-white text-gray-800 border-gray-200 hover:bg-gray-50'" class="px-3 py-1.5 rounded-lg border text-sm">+ New</button>
            </div>
            <button @click="toggleTheme" :class="theme==='dark' ? 'bg-white/10 text-gray-100 border-white/20' : 'bg-white text-gray-800 border-gray-200'" class="px-3 py-1.5 rounded-lg border text-sm">{{ theme==='dark' ? 'Light mode' : 'Dark mode' }}</button>
          </div>
      </header>
        <main :class="theme==='dark' ? 'backdrop-blur-xl bg-white/10 border-white/10' : 'bg-white/80 border-gray-200'" class="w-full max-w-2xl flex-1 flex flex-col border rounded-2xl shadow-xl px-0 sm:px-5 py-5">
        <!-- Chat Box -->
        <div ref="chatbox" class="flex-1 overflow-y-auto space-y-4 px-4 pb-4" style="min-height: 420px" v-cloak>
          <div v-for="(msg, idx) in messages" :key="idx" class="flex" :class="msg.role === 'user' ? 'justify-end' : 'justify-start'">
            <div :class="msg.role === 'user' ? (theme==='dark' ? 'bg-indigo-600/90 text-white' : 'bg-indigo-600 text-white') : (theme==='dark' ? 'bg-white/10 text-gray-100 border border-white/10' : 'bg-white text-gray-800 border border-gray-200')" class="px-4 py-3 rounded-2xl max-w-[82%] shadow">
              <div v-if="msg.role === 'assistant'" :class="theme==='dark' ? 'prose prose-invert prose-sm max-w-none' : 'prose prose-sm max-w-none'" v-html="renderMarkdown(msg.content)"></div>
              <div v-else class="whitespace-pre-line">{{ msg.content }}</div>
            </div>
          </div>
          <!-- Suggested Prompts (always visible at bottom) -->
          <div v-if="!loading" class="flex flex-col gap-2 mt-4 mb-2">
            <p :class="theme==='dark' ? 'text-gray-400' : 'text-gray-500'" class="text-sm mb-2 text-center">Try asking:</p>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
              <button
                v-for="(prompt, idx) in displayedPrompts"
                :key="idx"
                @click="usePrompt(prompt)"
                :class="theme==='dark' ? 'bg-white/5 hover:bg-white/10 border-white/10 text-gray-200' : 'bg-gray-50 hover:bg-gray-100 border-gray-200 text-gray-700'"
                class="px-4 py-3 rounded-xl border text-left text-sm transition cursor-pointer"
                :disabled="loading"
              >
                {{ prompt }}
              </button>
            </div>
          </div>
        </div>
        <!-- Loading Progress Bar -->
        <div v-if="loading" class="px-4 pt-2">
          <div class="mb-2">
            <div class="flex justify-between items-center mb-1">
              <span :class="theme==='dark' ? 'text-gray-300' : 'text-gray-600'" class="text-xs">AI is thinking...</span>
              <span :class="theme==='dark' ? 'text-gray-400' : 'text-gray-500'" class="text-xs">{{ estimatedTimeLeft > 0 ? `~${estimatedTimeLeft}s` : '' }}</span>
            </div>
            <div :class="theme==='dark' ? 'bg-gray-700/50' : 'bg-gray-200'" class="h-1.5 rounded-full overflow-hidden">
              <div :class="theme==='dark' ? 'bg-indigo-400' : 'bg-indigo-600'" class="h-full rounded-full transition-all duration-300" :style="{ width: loadingProgress + '%' }"></div>
            </div>
          </div>
        </div>
        <!-- Input area -->
        <form @submit.prevent="sendMessage" class="flex items-end gap-3 mt-4 px-4 pb-1">
          <input
            v-model="input"
            @keydown.enter.exact.prevent="sendMessage"
            type="text"
            placeholder="Type your message..."
            :class="theme==='dark' ? 'bg-white/10 border-white/10 text-gray-100 placeholder-gray-300' : 'bg-white border-gray-300 text-gray-800 placeholder-gray-500'"
            class="flex-1 rounded-xl px-4 py-3 border focus:outline-none focus:ring-2 focus:ring-indigo-400/60 focus:border-transparent"
            :disabled="loading"
            autocomplete="off"
          />
          <button
            type="submit"
            :class="theme==='dark' ? 'bg-indigo-600 hover:bg-indigo-500 active:bg-indigo-700 text-white' : 'bg-indigo-600 hover:bg-indigo-500 active:bg-indigo-700 text-white'"
            class="font-semibold px-5 py-3 rounded-xl transition disabled:opacity-50"
            :disabled="loading || !input.trim()"
          >
            {{ loading ? '...' : 'Send' }}
          </button>
        </form>
      </main>
      <footer :class="theme==='dark' ? 'text-gray-300/80' : 'text-gray-500'" class="text-xs my-6 text-center w-full">Powered by OpenRouter API • Model: set in code below</footer>
    </div>
    <script>
      // OpenRouter endpoint – leave as-is
      const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
      // PLACE API KEY HERE (must start with sk-or-v1-)
      const OPENROUTER_API_KEY = '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';
      // PLACE MODEL SLUG HERE (e.g. deepseek/deepseek-chat-v3.1:free)
      const OPENROUTER_MODEL = 'deepseek/deepseek-chat-v3.1:free';

      const { createApp, nextTick } = Vue;
      
      createApp({
        data() {
          return {
            messages: [
              { role: 'assistant', content: 'Hello! How can I help you today?' },
            ],
            input: '',
            loading: false,
            theme: 'dark',
            showHistory: false,
            history: [],
            historySearchQuery: '',
            loadingProgress: 0,
            estimatedTimeLeft: 0,
            loadingStartTime: 0,
            loadingInterval: null,
            suggestedPrompts: [
              'Explain quantum computing in simple terms',
              'Write a short story about a robot',
              'What are the benefits of meditation?',
              'How does photosynthesis work?',
              'Give me cooking tips for beginners',
              'Explain the theory of relativity',
              'What are renewable energy sources?',
              'Help me write a professional email',
            ],
          };
        },
        computed: {
          displayedPrompts() {
            return this.suggestedPrompts.slice(0, 4);
          },
          filteredHistory() {
            if (!this.historySearchQuery.trim()) {
              return this.history;
            }
            const query = this.historySearchQuery.toLowerCase();
            return this.history.filter(item => {
              const title = (item.title || '').toLowerCase();
              const firstMsg = item.messages?.find(m => m.role === 'user')?.content?.toLowerCase() || '';
              return title.includes(query) || firstMsg.includes(query);
            });
          },
        },
        methods: {
          usePrompt(prompt) {
            this.input = prompt;
            this.$nextTick(() => {
              this.sendMessage();
            });
          },
          renderMarkdown(text) {
            try {
              const html = marked.parse(text || '');
              return DOMPurify.sanitize(html);
            } catch (_) {
              return DOMPurify.sanitize(text || '');
            }
          },
          toggleTheme() {
            this.theme = this.theme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('CHAT_THEME', this.theme);
          },
          formatTime(timestamp) {
            const d = new Date(timestamp);
            const now = new Date();
            const diffMs = now - d;
            const diffMins = Math.floor(diffMs / 60000);
            if (diffMins < 60) return diffMins === 0 ? 'Just now' : `${diffMins}m ago`;
            const diffHours = Math.floor(diffMins / 60);
            if (diffHours < 24) return `${diffHours}h ago`;
            const diffDays = Math.floor(diffHours / 24);
            if (diffDays < 7) return `${diffDays}d ago`;
            return d.toLocaleDateString();
          },
          generateHistoryTitle(messages) {
            const userMessages = messages.filter(m => m.role === 'user');
            if (userMessages.length === 0) return 'New Chat';
            if (userMessages.length === 1) {
              const text = userMessages[0].content.trim();
              return text.length > 50 ? text.substring(0, 50) + '...' : text;
            }
            // Combine first and second user messages
            const first = userMessages[0].content.trim();
            const second = userMessages[1].content.trim();
            const combined = first.length > 30 ? first.substring(0, 30) : first;
            const suffix = second.length > 20 ? second.substring(0, 20) + '...' : second;
            return `${combined} | ${suffix}`;
          },
          saveToHistory() {
            if (this.messages.length <= 1) return;
            const title = this.generateHistoryTitle(this.messages);
            const entry = {
              timestamp: Date.now(),
              title: title,
              messages: [...this.messages],
            };
            // Check if this conversation already exists (prevent duplicates on every save)
            const existingIdx = this.history.findIndex(h => JSON.stringify(h.messages) === JSON.stringify(entry.messages));
            if (existingIdx !== -1) {
              this.history.splice(existingIdx, 1);
            }
            this.history.unshift(entry);
            if (this.history.length > 50) this.history = this.history.slice(0, 50);
            localStorage.setItem('CHAT_HISTORY', JSON.stringify(this.history));
          },
          loadHistoryItem(item, filteredIdx) {
            if (this.messages.length > 1) {
              this.saveToHistory();
            }
            // Find the actual index in the full history array
            const actualIdx = this.history.findIndex(h => h.timestamp === item.timestamp);
            if (actualIdx === -1) return;
            const entry = this.history[actualIdx];
            this.messages = [...entry.messages];
            this.showHistory = false;
            this.historySearchQuery = '';
            this.$nextTick(() => this.scrollToBottom());
          },
          clearHistory() {
            if (confirm('Clear all chat history?')) {
              this.history = [];
              localStorage.removeItem('CHAT_HISTORY');
              this.showHistory = false;
            }
          },
          startNewChat() {
            if (this.messages.length > 1) {
              this.saveToHistory();
            }
            this.messages = [
              { role: 'assistant', content: 'Hello! How can I help you today?' },
            ];
            this.$nextTick(() => this.scrollToBottom());
          },
          startLoadingProgress() {
            this.loadingStartTime = Date.now();
            this.loadingProgress = 0;
            this.estimatedTimeLeft = 5; // Initial estimate: 5 seconds
            const estimatedDuration = 5000; // 5 seconds base estimate
            
            this.loadingInterval = setInterval(() => {
              const elapsed = Date.now() - this.loadingStartTime;
              // Progress increases but caps at 95% until actual response
              this.loadingProgress = Math.min(95, (elapsed / estimatedDuration) * 95);
              // Update time estimate (adaptive - longer waits increase estimate)
              if (elapsed < estimatedDuration) {
                this.estimatedTimeLeft = Math.max(1, Math.ceil((estimatedDuration - elapsed) / 1000));
              } else {
                // After initial estimate, show "thinking..."
                this.estimatedTimeLeft = Math.max(0, Math.ceil((estimatedDuration * 1.5 - elapsed) / 1000));
              }
            }, 100); // Update every 100ms
          },
          stopLoadingProgress() {
            if (this.loadingInterval) {
              clearInterval(this.loadingInterval);
              this.loadingInterval = null;
            }
            this.loadingProgress = 100;
            setTimeout(() => {
              this.loadingProgress = 0;
              this.estimatedTimeLeft = 0;
            }, 300);
          },
          async sendMessage() {
            const content = this.input.trim();
            if (!content || this.loading) return;
            this.messages.push({ role: 'user', content });
            this.input = '';
            this.loading = true;
            this.startLoadingProgress();
            await nextTick();
            this.scrollToBottom();
            try {
              // Prepare the conversation
              const conversation = this.messages.map(m => ({ role: m.role, content: m.content }));
              const maxRetries = 3;
              let data = null;
              for (let attempt = 0; attempt <= maxRetries; attempt++) {
              const res = await fetch(OPENROUTER_API_URL, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
                  'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                  'HTTP-Referer': window.location.origin || 'http://localhost',
                  'X-Title': 'Chat with AI',
                },
                body: JSON.stringify({
                  model: OPENROUTER_MODEL,
                  messages: conversation,
                }),
              });
                // Retry on common rate-limit/overload statuses
                if ((res.status === 429 || res.status === 503 || res.status === 529) && attempt < maxRetries) {
                  const waitMs = 1000 * Math.pow(2, attempt); // 1s, 2s, 4s
                  await new Promise(r => setTimeout(r, waitMs));
                  continue;
                }
              if (!res.ok) {
                const errText = await res.text().catch(() => '');
                throw new Error(`API error ${res.status}: ${errText}`);
              }
                data = await res.json();
                break;
              }
              let reply = '';
              reply = data?.choices?.[0]?.message?.content ?? data?.choices?.[0]?.content ?? '';
              reply = typeof reply === 'string' ? reply.trim() : '';
              // Remove all token markers (comprehensive cleanup)
              reply = reply.replace(/<\|redacted_begin_of_sentence\|>/gi, '')
                           .replace(/<\s*\|\s*redacted_begin_of_sentence\s*\|\s*>/gi, '')
                           .replace(/<\s*\|\s*begin_of_sentence\s*\|\s*>/gi, '')
                           .replace(/<\|begin_of_sentence\|>/gi, '')
                           .replace(/\|\s*redacted_begin_of_sentence\s*\|/gi, '')
                           .replace(/\|redacted_begin_of_sentence\|/gi, '')
                           .replace(/\|\s*begin_of_sentence\s*\|/gi, '')
                           .replace(/\|begin_of_sentence\|/gi, '')
                           .replace(/<\|redacted[^|]*\|>/gi, '')
                           .replace(/<\|[^|]*begin_of_sentence[^|]*\|>/gi, '')
                           .replace(/\{\|redacted[^|]*\|\}/gi, '')
                           .replace(/\[redacted[^\]]*\]/gi, '')
                           .replace(/redacted_begin_of_sentence/gi, '')
                           .replace(/begin_of_sentence/gi, '')
                           .trim();
              if (!reply) reply = 'Sorry, I could not generate a reply. Please try again.';
              this.messages.push({ role: 'assistant', content: reply });
              await nextTick();
              this.scrollToBottom();
              // Auto-save to history after each exchange
              this.saveToHistory();
            } catch (err) {
              const msg = err && err.message ? err.message : 'Failed to contact AI.';
              const friendly = msg.includes('API error 429') || msg.includes('API error 503') || msg.includes('API error 529')
                ? 'The free upstream pool is rate-limited right now. Please wait a few seconds and try again. If this keeps happening, use your own OpenRouter API key to accumulate your own limits.'
                : msg;
              this.messages.push({ role: 'assistant', content: `Error: ${friendly}` });
              await nextTick();
              this.scrollToBottom();
            } finally {
              this.loading = false;
              this.stopLoadingProgress();
            }
          },
          scrollToBottom() {
            this.$refs.chatbox.scrollTop = this.$refs.chatbox.scrollHeight;
          },
        },
        mounted() {
          const saved = localStorage.getItem('CHAT_THEME');
          if (saved === 'light' || saved === 'dark') {
            this.theme = saved;
          } else {
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            this.theme = prefersDark ? 'dark' : 'light';
          }
          // Load history
          const hist = localStorage.getItem('CHAT_HISTORY');
          if (hist) {
            try {
              this.history = JSON.parse(hist);
              // Generate titles for old entries that don't have them
              this.history = this.history.map(item => {
                if (!item.title && item.messages) {
                  item.title = this.generateHistoryTitle(item.messages);
                }
                return item;
              });
              localStorage.setItem('CHAT_HISTORY', JSON.stringify(this.history));
            } catch (_) {}
          }
          this.scrollToBottom();
          // Save history before page closes/unloads
          window.addEventListener('beforeunload', () => {
            if (this.messages.length > 1) {
              this.saveToHistory();
            }
          });
        },
        updated() {
          this.scrollToBottom();
        }
      }).mount('#app');
    </script>
  </body>
</html>



**INDEX**
